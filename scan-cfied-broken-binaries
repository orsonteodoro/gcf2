#!/bin/bash
FULL_SCAN=${FULL_SCAN:=0}
SHOW_ERRORS=${SHOW_ERRORS:=1}
LOGGING=${LOGGING:=1} # do not turn off
LOGGING_PATH=${LOGGING_PATH:=/var/log/cfi-scan.log}
gen_log() {
	echo
	echo "Scanning system for CFI violations and breakage.  Please wait..."
	echo "You can stop anytime with kill -9 $$"
	echo
	echo "* This may crash X and lose unsaved work."
	echo "* It is not recommended to run this script with an unclean (or"
	echo "     possibly compromised) computer."
	echo
	echo "Press Ctrl+C now to quit or wait 20 secs to proceed."
	echo
	sleep 20
	echo
	echo "When scanning is done you may see the results by running \`<path> --help\`"
	echo
	local exclude=(
		# basename goes here
	)
	local error_list_=(
		"control flow integrity"
		"failed to allocate noreserve"
		"__cfi_"
		"__dso_handle"
		"CFI: CHECK failed:"
		"__ubsan_handle"
	)
	local full_scan_paths=(
		# Add your custom paths here
		$(realpath /usr/*/gcc-bin)
		$(realpath /usr/lib*)
		/opt
	)
	if (( ${LOGGING} == 1 )) ; then
		echo "" > "${LOGGING_PATH}"
		echo "Logging is enabled.  See ${LOGGING_PATH} for details."
	else
		echo "Logging is disabled.  Set LOGGING=1 to generate a log."
	fi
	local error_list=$(for l in "${error_list_[@]}" ; do echo "${l}" ; done | tr "\n" "|" | sed -e "s/|$//g")
	# Add more search paths below if necessary.
	local full_scan_paths_=( /bin /sbin /usr/bin /usr/sbin )
	if (( ${FULL_SCAN} == 1 )) ; then
		full_scan_paths_=( ${full_scan_paths_[@]} ${full_scan_paths[@]} )
		echo "Full scan enabled:  ${full_scan_paths_[@]}"
	else
		echo "Full scan disabled:  ${full_scan_paths_[@]}"
	fi
	echo "Set FULL_SCAN=1 to scan all paths."
	for f in $(find ${full_scan_paths_[@]} -executable) ; do
		local is_exe=1
		file "${f}" | grep -q -e "ELF.*shared object" && is_exe=0
		#file "${f}" | grep -q -e "symbolic link" && is_exe=0
		(( ${is_exe} == 0 )) && continue
		local skip=0
		for n in ${exclude[@]} ; do
			[[ "${f}" =~ "${n}" ]] && skip=1
		done
		if (( ${skip} == 1 )) ; then
			echo "Skipping ${f}"
			continue
		fi
		local error_found=0
		if (( ${LOGGING} == 1 )) ; then
			#echo "Inspecting ${f}" >> "${LOGGING_PATH}"
			if timeout -s SIGKILL 2 ${f} --help 2>&1 | grep -q -E -e "(${error_list})" ; then
				error_found=1
				local pkg_name=$(grep -l "${f}" /var/db/pkg/*/*/CONTENTS)
				echo "Detected in ${f} (pkg_name = ${pkg_name}):"
				echo "Detected in ${f} (pkg_name = ${pkg_name}):" >> "${LOGGING_PATH}"
			fi
		else
			timeout -s SIGKILL 2 ${f} --help 2>&1 \
				| grep -q -E -e "(${error_list})" && echo "Detected in ${f}"
		fi
		if (( ${SHOW_ERRORS} == 1 && ${error_found} == 1 )) ; then
			timeout -s SIGKILL 2 bash -c "(\"${f}\" --help 1>/dev/null ; echo "----")"
			timeout -s SIGKILL 2 bash -c "(\"${f}\" --help 2>> \"${LOGGING_PATH}\" ; echo "----" >> \"${LOGGING_PATH}\")"
		fi
	done
}

find_slowpath_errors() {
	echo
	echo "__cfi_slowpath_diag errors from:"
	echo
	for f in $(grep -e "__cfi_slowpath_diag" "${LOGGING_PATH}" | grep -o -E " /.*.so[.0-9]+" | sort | uniq) ; do
		echo "${f}: "$(grep -l "${f}" /var/db/pkg/*/*/CONTENTS | sed -r -e "s|/var/db/pkg/||g" -e "s|/CONTENTS||g")
	done
	echo
}

find_check_fail_abort_errors() {
	echo
	echo "__ubsan_handle_cfi_check_fail_abort errors from:"
	echo
	for f in $(grep -e "__ubsan_handle_cfi_check_fail_abort" "${LOGGING_PATH}" | grep -o -E " /.*.so[.0-9]+" | sort | uniq) ; do
		echo "${f}: "$(grep -l "${f}" /var/db/pkg/*/*/CONTENTS | sed -r -e "s|/var/db/pkg/||g" -e "s|/CONTENTS||g")
	done
	echo
}

find_indirect_function_call_errors() {
	echo
	echo "indirect function call errors from (src):"
	echo
	grep -r -e "indirect function call" /var/log/cfi-scan.log | cut -f 1 -d ":" | sort | uniq
	echo
	echo "indirect function call errors from (lib):"
	echo
	for f in $(cat /var/log/cfi-scan.log | pcregrep -M  "indirect function call\n[(]" | sed -e ':a;N;$!ba;s/\n[(]/ (/g' | grep -o -e "(/.*.so.*):" | sed -r -e "s|\):||g" -e "s|\(||g" -e "s|\+0x[0-9a-z]+$||g" | sort | uniq) ; do
		echo "${f}: "$(grep -l "${f}" /var/db/pkg/*/*/CONTENTS | sed -r -e "s|/var/db/pkg/||g" -e "s|/CONTENTS||g")
	done
	echo
}

analysis() {
	find_slowpath_errors
	find_check_fail_abort_errors
	find_indirect_function_call_errors
	echo "Manual analysis still required because of parsing difficulty.  See ${LOGGING_PATH} for details."
}

main() {
	gen_log
	analysis
}

main
