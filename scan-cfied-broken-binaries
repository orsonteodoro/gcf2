#!/bin/bash
FULL_SCAN=${FULL_SCAN:=1}
ALLOW_OPT=${ALLOW_OPT:=0}
SHOW_ERRORS=${SHOW_ERRORS:=1}
LOGGING_PATH=${LOGGING_PATH:=/var/log/cfi-scan.log}
ANALYSIS="${ANALYSIS:=1}"
GEN_LOG="${GEN_LOG:=1}"

decho() {
	echo "${@}" >> "${LOGGING_PATH}"
	echo "${@}"
}

dcat() {
	cat "${1}" >> "${LOGGING_PATH}"
	cat "${1}"
}

banner() {
	echo
	echo "Scanning system for CFI violations and breakage.  Please wait..."
	echo
	echo "* This may crash X and lose unsaved work."
	echo "* It is not recommended to run this script with an unclean (or"
	echo "     possibly compromised) computer."
	echo
	echo "Press Ctrl+C now to quit or wait 20 secs to proceed."
	echo
	sleep 20
}

gen_log() {
	local arg="${1}"
	echo
	echo "When scanning is done you may see the results by running \`<path> ${arg}\`"
	echo
	local exclude=(
		# basename goes here
		startx
	)
	local error_list_=(
		"control flow integrity"
		"failed to allocate noreserve"
		"__cfi_"
		"__dso_handle"
		"CFI: CHECK failed:"
		"__ubsan_handle"
	)
	local full_scan_paths=(
		# Add your custom paths here
		$(realpath /usr/*/gcc-bin)
		$(realpath /usr/lib*)
		/opt/firefox
		/opt/google
		/opt/openjdk-bin-11.0.13_p8
		/opt/rust-bin-1.56.1
		/opt/spotify
	)
	(( ${ALLOW_OPT} )) && full_scan_paths+=( /opt )
	local error_list=$(for l in "${error_list_[@]}" ; do echo "${l}" ; done | tr "\n" "|" | sed -e "s/|$//g")
	# Add more search paths below if necessary.
	local full_scan_paths_=( /bin /sbin /usr/bin /usr/sbin )
	if (( ${FULL_SCAN} == 1 )) ; then
		full_scan_paths_=( ${full_scan_paths_[@]} ${full_scan_paths[@]} )
		echo "Full scan enabled:  ${full_scan_paths_[@]}"
	else
		echo "Full scan disabled:  ${full_scan_paths_[@]}"
	fi
	echo "Set FULL_SCAN=1 to scan all paths."
	decho "----" >> "${LOGGING_PATH}"
	decho "" >> "${LOGGING_PATH}"
	for f in $(find ${full_scan_paths_[@]} -executable) ; do
		local is_exe=1
		file "${f}" | grep -q -e "ELF.*shared object" && is_exe=0
		#file "${f}" | grep -q -e "symbolic link" && is_exe=0
		(( ${is_exe} == 0 )) && continue
		local skip=0
		local bn=$(basename "${f}")
		for n in ${exclude[@]} ; do
			[[ "${bn}" == "${n}" ]] && skip=1
		done
		if (( ${skip} == 1 )) ; then
			echo "Skipping ${f}"
			continue
		fi
		local error_found=0
		#echo "Inspecting ${f}" >> "${LOGGING_PATH}"
		if timeout -s SIGKILL 2 ${f} ${arg} 2>&1 | grep -q -E -e "(${error_list})" ; then
			error_found=1
			local pkg_name=$(grep -l "${f}" /var/db/pkg/*/*/CONTENTS | sed -e "s|/var/db/pkg/||g" -e "s|/CONTENTS||g" | tr "\n" " ")
			decho "Detected in ${f} (pkg_name = ${pkg_name}):"
		fi
		if (( ${SHOW_ERRORS} == 1 && ${error_found} == 1 )) ; then
			timeout -s SIGKILL 2 bash -c "(\"${f}\" ${arg} 1>/dev/null 2> \"${SANDBOX_DIR}/output.log\")"
			dcat "${SANDBOX_DIR}/output.log"
			decho ""
			decho "----"
			decho ""
			# Make it easier to extract for condensed analysis
			if grep -q -e "CFI: CHECK failed" "${SANDBOX_DIR}/output.log" ; then
				decho "CFI: CHECK failed: (${pkg_name})"
			fi
			if grep -q -e "failed to allocate noreserve" "${SANDBOX_DIR}/output.log" ; then
				echo "failed to allocate noreserve (${pkg_name})" >> "${LOGGING_PATH}"
				for g in $(grep -E -e "/usr/.*" "${SANDBOX_DIR}/output.log") ; do
					[[ "${g}" =~ ^0x ]] && continue
					decho "noreserve: ${g} : "$(grep -l "${g}" /var/db/pkg/*/*/CONTENTS | sed -e "s|/var/db/pkg/||g" -e "s|/CONTENTS||g")
				done
				for g in $(grep -E -e ".*/lib.*" "${SANDBOX_DIR}/output.log") ; do
					[[ "${g}" =~ ^0x ]] && continue
					decho "noreserve: ${g} : "$(grep -l "${g}" /var/db/pkg/*/*/CONTENTS | sed -e "s|/var/db/pkg/||g" -e "s|/CONTENTS||g")
				done
			fi
		fi
	done
}

find_slowpath_errors() {
	echo
	echo "__cfi_slowpath_diag errors from:"
	echo
	for f in $(grep -e "__cfi_slowpath_diag" "${LOGGING_PATH}" | grep -o -E " /.*.so[.0-9]+" | sort | uniq) ; do
		echo "${f}: "$(grep -l "${f}" /var/db/pkg/*/*/CONTENTS | sed -r -e "s|/var/db/pkg/||g" -e "s|/CONTENTS||g")
	done
	echo
}

find_check_fail_abort_errors() {
	echo
	echo "__ubsan_handle_cfi_check_fail_abort errors from:"
	echo
	for f in $(grep -e "__ubsan_handle_cfi_check_fail_abort" "${LOGGING_PATH}" | grep -o -E " /.*.so[.0-9]+" | sort | uniq) ; do
		echo "${f}: "$(grep -l "${f}" /var/db/pkg/*/*/CONTENTS | sed -r -e "s|/var/db/pkg/||g" -e "s|/CONTENTS||g")
	done
	echo
}

find_indirect_function_call_errors() {
	echo
	echo "indirect function call errors from (src):"
	echo
	grep -r -e "indirect function call" "${LOGGING_PATH}" | cut -f 1 -d ":" | sort | uniq
	echo
	echo "indirect function call errors from (lib):"
	echo
	for f in $(cat "${LOGGING_PATH}" | pcregrep -M "indirect function call\n[(]" | sed -e ':a;N;$!ba;s/\n[(]/ (/g' | grep -o -e "(/.*.so.*):" | sed -r -e "s|\):||g" -e "s|\(||g" -e "s|\+0x[0-9a-z]+$||g" | sort | uniq) ; do
		echo "${f}: "$(grep -l "${f}" /var/db/pkg/*/*/CONTENTS | sed -r -e "s|/var/db/pkg/||g" -e "s|/CONTENTS||g")
	done
	echo
}

find_noreserve_libs_errors() {
	echo
	echo "noreserve errors (libs):"
	echo
	grep "noreserve:" "${LOGGING_PATH}" | sort | uniq
}

find_cfi_check_failed_errors() {
	echo
	echo "CFI: CHECK failed errors (libs):"
	echo
	grep "CFI: CHECK failed:" "${LOGGING_PATH}" | sort | uniq
}

analysis() {
	find_slowpath_errors
	find_check_fail_abort_errors
	find_indirect_function_call_errors
	find_noreserve_libs_errors
	find_cfi_check_failed_errors
	echo "Manual analysis still required because of parsing difficulty.  See ${LOGGING_PATH} for details."
}

cleanup() {
	echo "Removing sandbox"
	rm -rf "${sandboxdir}"
	exit 1
}

install_traps() {
	trap cleanup INT
	trap cleanup KILL
	trap cleanup ABRT
	trap cleanup QUIT
}

main() {
	export SANDBOX_DIR=$(mktemp -d)
	mkdir -p "${SANDBOX_DIR}"
	pushd "${SANDBOX_DIR}"
	install_traps
	banner
	echo "" > "${LOGGING_PATH}"
	local args=(
		"--help"
		"--version"
	)
	for a in ${args[@]} ; do
		(( ${GEN_LOG} == 1 )) && gen_log "${a}"
	done
	(( ${ANALYSIS} == 1)) && analysis
	popd
	cleanup
}

main
