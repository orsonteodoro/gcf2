#!/bin/bash

# Notes:
#*_OPT acceptable values O1.conf, O1.conf, O2.conf, O3.conf, O4.conf, Oz.conf, Os.conf, Ofast.conf Ofast-mt.conf
# You may add additional settings as follows FMATH_OPT="march-native.conf O1.conf ffast-math.conf"

SCRIPT_NAME=$(basename "$0")
DIR_SCRIPT=$(dirname "$0")
ARGV="${@}"

export ASM_OPT="O3.conf"
export ARCHIVES_AUTOFETCH=1 # Also called tarballs
export ARCHIVES_SKIP_LARGE=${ARCHIVES_SKIP_LARGE:-1}
export ARCHIVES_SKIP_LARGE_CUTOFF_SIZE=${ARCHIVES_SKIP_LARGE_CUTOFF_SIZE:-100000000}
#export ARCHIVES_SKIP_LARGE_CUTOFF_SIZE=${ARCHIVES_SKIP_LARGE_CUTOFF_SIZE:-1000000}
export CODE_PCT="0.3882814715311033" # Average among small sample
export CRYPTO_ASYM_OPT="${CRYPTO_ASYM_OPT:-Ofast-ts.conf}" # Based on benchmarks, expensive
export CRYPTO_CHEAP_OPT="${CRYPTO_CHEAP_OPT:-O1.conf}"
export CRYPTO_EXPENSIVE_OPT="${CRYPTO_EXPENSIVE_OPT:-O3.conf}"
export DATA_COMPRESSION_RATIO="6.562980063720293" # average among small sample ; DATA_COMPRESSION_RATIO = UNCOMPRESSED_SIZE / COMPRESSED_SIZE
export DEVELOPER_MODE="1"
export DISTDIR="${DISTDIR:-/var/cache/distfiles}"
export FMATH_OPT="${FMATH_OPT:-Ofast-mt.conf}"
export FMATH_UNSAFE_CFG="${FMATH_UNSAFE_CFG:-no-fast-math.conf}"
export HEAVY_LOC_OPT="O1.conf" # Optimize for build speed instead.  Often it is the data size not the code that is the problem.
export HEAVY_LOC_SIZE=${HEAVY_LOC_SIZE:-10000000} # 10M ELOC ; Match the number for 8 hr builds
export LAYMAN_BASEDIR="${LAYMAN_BASEDIR:-/var/lib/layman}"
export LINEAR_MATH_OPT="O3.conf"
export LOCB_RATIO="0.030879526993880038" # average of Python and C/C++ ratios of below formula \
#  LOC = Lines Of Code \
#  MLOC = Million Lines Of Code \
#  LOCB_RATIO = LINES_OF_CODE / T_SOURCE_CODE_BYTES \
#  Python LOCB ratio:  0.034346428375619575 \
#  C/C++ LOCB ratio:  0.027412625612140498 \
export OILEDMACHINE_OVERLAY_DIR="${OILEDMACHINE_OVERLAY_DIR:-/usr/local/oiledmachine-overlay}"
export OPENGL_OPT="O3.conf"
export PORTAGE_DIR="${PORTAGE_DIR:-/usr/portage}"
export SIMD_OPT="O3.conf"
export SKIP_INTRO_PAUSE=0
export SSA_SIZE=${SSA_SIZE:-1000000} # 1M ELOC (Estimated Lines Of Code)
export SSA_OPT="O1.conf"
export WOPT=${WOPT:-"20"}
export WPKG=${WPKG:-"50"}

show_help() {
echo
echo "${SCRIPT_NAME} [options]"
echo
echo "Options:"
echo
echo "  -h, --help			Shows help"
echo "  -rc, --rebuild-cache		Rebuilds caches"
echo
}

remove_caches() {
	rm -fv package.env.t
	rm -fv "${DIR_SCRIPT}/a_to_p.cache"
}

parse_command_line_args() {
	local argv=(${ARGV})
	for x in ${argv[@]} ; do
		case ${x} in
			--help|-h)
				show_help
				exit 0
				;;
			--rebuild-cache|-rc)
				remove_caches
				;;
		esac
	done
}

# See also gen_overlay_paths

get_path_pkg_idx() {
	local manifest_path="${1}"
	echo $(ls "${manifest_path}" | grep -o -e "/" | wc -l)
}

is_pkg_skippable() {
	[[ "${cat_p}" =~ "-bin"$ ]] && return 0
	[[ "${cat_p}" =~ "-data"$ ]] && return 0
	[[ "${cat_p}" =~ "acct-"("group"|"user") ]] && return 0
	[[ "${cat_p}" =~ "firmware" ]] && return 0
	[[ "${cat_p}" =~ "media-fonts" ]] && return 0
	[[ "${cat_p}" =~ "virtual/" ]] && return 0
	[[ "${cat_p}" =~ "x11-themes" ]] && return 0
	return 1
}

gen_ssa_opt_list() {
	echo "Processing SSA"
	echo "" >> package.env
	echo "# Large projects were marked for SSA optimizations" >> package.env
	echo "# (Heavy LOCs deferred in different section below)" >> package.env
	echo "# Autogenerated list" >> package.env
	echo "" >> package.env
	local path

	echo -n "" > package.env.t.loc
	echo -n "" > package.env.t.ssa
	local op
	for op in ${OVERLAY_PATHS[@]} ; do
		for path in $(find "${op}" -type f -name "Manifest") ; do
			local idx_pn=$(get_path_pkg_idx "${path}")
			local idx_cat=$(( ${idx_pn} - 1 ))
			local cat_p=$(echo "${path}" | cut -f ${idx_cat}-${idx_pn} -d "/")
			is_pkg_skippable && continue
			local pn=$(echo "${path}" | cut -f ${idx_pn} -d "/")
			local on=$(basename "${op}")
			echo "SSA:  Processing ${cat_p}::${on}"
			local filesize=$(grep -e "DIST" "${path}" | cut -f 3 -d " " | sort -n | tail -n 1)
			[[ -z "${filesize}" ]] && continue
			local loc=$(python -c "print(${LOCB_RATIO}*${filesize}*${DATA_COMPRESSION_RATIO}*${CODE_PCT})" | cut -f 1 -d ".")
			local mloc=$(python -c "print(${LOCB_RATIO}*${filesize}*${DATA_COMPRESSION_RATIO}*${CODE_PCT}/1000000)")
			if (( ${loc} >= ${HEAVY_LOC_SIZE} )) ; then
				printf "%-${WPKG}s%-${WOPT}s %s\n" "${cat_p}" "${HEAVY_LOC_OPT}" "# Archive size: ${filesize} ; Estimated MLOC: ${mloc}" >> package.env.t.loc
			elif (( ${loc} >= ${SSA_SIZE} )) ; then
				printf "%-${WPKG}s%-${WOPT}s %s\n" "${cat_p}" "${SSA_OPT}" "# Archive size: ${filesize} ; Estimated MLOC: ${mloc}" >> package.env.t.ssa
			fi
		done
	done
	cat package.env.t.ssa | sort | uniq >> package.env
	echo "" >> package.env
}

gen_loc_list() {
	echo "Processing heavy LOC"
	echo "" >> package.env
	echo "# Reducing build times for large projects" >> package.env
	echo "# Autogenerated list" >> package.env
	echo "" >> package.env
	cat package.env.t.loc | sort | uniq >> package.env
	echo "" >> package.env
}

gen_crypto_list() {
	echo "Processing crypto"
	echo
	echo "Generating crypto list.  This may take several minutes.  Please wait..."
	echo

	echo "" >> package.env
	echo "# Cryptography" >> package.env
	echo "# Autogenerated list" >> package.env
	echo "" >> package.env
	echo -n "" > package.env.t
	./gen_crypto_package_lst.sh
	cat package.env.t | sort | uniq >> package.env
	echo "" >> package.env
}

gen_opengl_list() {
	echo "Processing OGL"
	echo "" >> package.env
	echo "# 3D (games, apps, ...)" >> package.env
	echo "# Autogenerated list" >> package.env
	echo "" >> package.env

	echo -n "" > package.env.t
	local op
	for op in ${OVERLAY_PATHS[@]} ; do
		local x
		for x in $(grep --exclude-dir=.git --exclude-dir=distfiles -l -E -i -r -e "opengl" "${op}" \
			| grep "ebuild")
		do
			local path=$(dirname "${x}/Manifest")
			local idx_pn=$(get_path_pkg_idx "${path}")
			local idx_cat=$(( ${idx_pn} - 1 ))
			local cat_p=$(echo "${path}" | cut -f ${idx_cat}-${idx_pn} -d "/")
			is_pkg_skippable && continue
			local pn=$(echo "${path}" | cut -f ${idx_pn} -d "/")
			[[ "${pn}" =~ "-bin"$ ]] && continue
			[[ "${cat_p}" =~ "virtual/" ]] && continue
			local on=$(basename "${op}")
			echo "OGL:  Processing ${cat_p}::${on}"
			printf "%-${WPKG}s%-${WOPT}s\n" "${cat_p}" "${OPENGL_OPT}" >> package.env.t
		done
	done
	cat package.env.t | sort | uniq >> package.env
	echo "" >> package.env
}

gen_simd_list() {
	echo "Processing SIMD"
	echo "" >> package.env
	echo "# SIMD (sse, mmx, avx, neon, ...)" >> package.env
	echo "# Autogenerated list" >> package.env
	echo "" >> package.env

	echo -n "" > package.env.t
	local op
	for op in ${OVERLAY_PATHS[@]} ; do
		local x
		for x in $(grep --exclude-dir=.git --exclude-dir=distfiles -l -E -i -r -e "cpu_flags" "${op}" \
			| grep "ebuild")
		do
			local path=$(dirname "${x}/Manifest")
			local idx_pn=$(get_path_pkg_idx "${path}")
			local idx_cat=$(( ${idx_pn} - 1 ))
			local cat_p=$(echo "${path}" | cut -f ${idx_cat}-${idx_pn} -d "/")
			is_pkg_skippable && continue
			local pn=$(echo "${path}" | cut -f ${idx_pn} -d "/")
			[[ "${pn}" =~ "-bin"$ ]] && continue
			[[ "${cat_p}" =~ "virtual/" ]] && continue
			local on=$(basename "${op}")
			echo "SIMD:  Processing ${cat_p}::${on}"
			printf "%-${WPKG}s%-${WOPT}s\n" "${cat_p}" "${SIMD_OPT}" >> package.env.t
		done
	done
	cat package.env.t | sort | uniq >> package.env
	echo "" >> package.env
}

gen_asm_list() {
	echo "Processing ASM"
	echo "" >> package.env
	echo "# ASM code but may contain the high level readable version" >> package.env
	echo "# Autogenerated list" >> package.env
	echo "" >> package.env

	echo -n "" > package.env.t
	local op
	for op in ${OVERLAY_PATHS[@]} ; do
		local x
		for x in $(grep --exclude-dir=.git --exclude-dir=distfiles -l -E -i -r -e "(yasm|nasm|( |\")asm)" "${op}" \
			| grep "ebuild")
		do
			local path=$(dirname "${x}/Manifest")
			local idx_pn=$(get_path_pkg_idx "${path}")
			local idx_cat=$(( ${idx_pn} - 1 ))
			local cat_p=$(echo "${path}" | cut -f ${idx_cat}-${idx_pn} -d "/")
			is_pkg_skippable && continue
			local pn=$(echo "${path}" | cut -f ${idx_pn} -d "/")
			[[ "${pn}" =~ "-bin"$ ]] && continue
			[[ "${cat_p}" =~ "virtual/" ]] && continue
			local on=$(basename "${op}")
			echo "ASM:  Processing ${cat_p}::${on}"
			printf "%-${WPKG}s%-${WOPT}s\n" "${cat_p}" "${ASM_OPT}" >> package.env.t
		done
	done
	cat package.env.t | sort | uniq >> package.env
	echo "" >> package.env
}

gen_float_math_list() {
	echo "Processing FMATH"
	echo "" >> package.env
	echo "# Floating point math packages" >> package.env
	echo "# Autogenerated list" >> package.env
	echo "" >> package.env
	echo -n "" > package.env.t
	./gen_float_package_lst.sh
	cat package.env.t | sort | uniq >> package.env
	echo "" >> package.env
}

gen_linear_math_list() {
	echo "Processing LMATH"
	echo "" >> package.env
	echo "# Linear math packages" >> package.env
	echo "# Autogenerated list" >> package.env
	echo "" >> package.env

	echo -n "" > package.env.t
	local op
	for op in ${OVERLAY_PATHS[@]} ; do
		local x
		for x in $(grep --exclude-dir=.git --exclude-dir=distfiles -l -E -i -r \
			-e "linear.*solver" \
			-e "((sci-libs|virtual)/(lapack|openblas|mkl-rt|blis)|eigen)" \
			"${PORTAGE_DIR}/"* \
			| grep "ebuild")
		do
			local path=$(dirname "${x}/Manifest")
			local idx_pn=$(get_path_pkg_idx "${path}")
			local idx_cat=$(( ${idx_pn} - 1 ))
			local cat_p=$(echo "${path}" | cut -f ${idx_cat}-${idx_pn} -d "/")
			local pn=$(echo "${path}" | cut -f ${idx_pn} -d "/")
			is_pkg_skippable && continue
			local on=$(basename "${op}")
			echo "LMATH:  Processing ${cat_p}::${on}"
			printf "%-${WPKG}s%-${WOPT}s\n" "${cat_p}" "${LINEAR_MATH_OPT}" >> package.env.t
		done
	done
	cat package.env.t | sort | uniq >> package.env
	echo "" >> package.env
}

archives_autofetch() {
	if [[ "${ARCHIVES_AUTOFETCH}" == "1" ]] ; then
		echo "Autofetching archives"
		emerge -fve world
	fi
}

header() {
	echo "ASM_OPT=${ASM_OPT}"
	echo "ARCHIVES_AUTOFETCH=${ARCHIVES_AUTOFETCH}"
	echo "CRYPTO_CHEAP_OPT=${CRYPTO_CHEAP_OPT}"
	echo "CRYPTO_EXPENSIVE_OPT=${CRYPTO_EXPENSIVE_OPT}"
	echo "CRYPTO_ASYM_OPT=${CRYPTO_ASYM_OPT}"
	echo "DISTDIR=${DISTDIR}"
	echo "FMATH_OPT=${FMATH_OPT}"
	echo "FMATH_UNSAFE_CFG=${FMATH_UNSAFE_CFG}"
	echo "HEAVY_LOC_OPT=${HEAVY_LOC_OPT}"
	echo "HEAVY_LOC_SIZE=${HEAVY_LOC_SIZE}"
	echo "LAYMAN_BASEDIR=${LAYMAN_BASEDIR}"
	echo "LINEAR_MATH_OPT=${LINEAR_MATH_OPT}"
	echo "OILEDMACHINE_OVERLAY_DIR=${OILEDMACHINE_OVERLAY_DIR}"
	echo "OPENGL_OPT=${OPENGL_OPT}"
	echo "PORTAGE_DIR=${PORTAGE_DIR}"
	echo "MATH_OPT=${MATH_OPT}"
	echo "SIMD_OPT=${SIMD_OPT}"
	echo "ARCHIVES_SKIP_LARGE=${ARCHIVES_SKIP_LARGE}"
	echo "ARCHIVES_SKIP_LARGE_CUTOFF_SIZE=${ARCHIVES_SKIP_LARGE_CUTOFF_SIZE}"
	echo "SSA_SIZE=${SSA_SIZE}"
	echo "SSA_OPT=${SSA_OPT}"

	[[ ! -d "${DISTDIR}" ]] && echo "Missing ${DISTDIR}.  Change DISTDIR in ${SCRIPT_NAME}"

	if [[ "${SKIP_INTRO_PAUSE}" != "1" ]] ; then
		echo
		echo "Edit global settings inside ${SCRIPT_NAME} now by pressing CTRL+C"
		echo "Continuing in 15 secs."
		echo
		sleep 15
	fi
}

gen_package_env() {
	echo
	echo "Generating package.env"
	echo

	[[ -e "package.env" ]] && mv package.env package-$(date +"%s").env.bak
	touch package.env

	cat package_env-header.txt >> package.env

#	gen_ssa_opt_list
	gen_float_math_list
#	gen_linear_math_list
#	gen_opengl_list
#	gen_asm_list
#	gen_simd_list
#	gen_crypto_list
#	gen_loc_list

	cat fixes.lst >> package.env
	cat static-opts.lst >> package.env
	cat build-control.lst >> package.env
	cat cfi.lst >> package.env
	cat makeopts.lst >> package.env
	cat testing.lst >> package.env
}

footer() {
echo "All work completed!"

echo
echo "NOTES:"
echo
echo "The crypto list needs to be manually edited."
echo
echo "The ffast-math with enabled flags list needs to be manually inspected and"
echo "edited.  Review the logs to see if the optimizations are safe."
echo
}

setup() {
	parse_command_line_args
	trap cleanups INT
	trap cleanups SIGTERM
	trap cleanups EXIT

	if ! ( grep --help | grep -q -F -e "--perl-regexp" ) ; then
echo "Rebuild sys-apps/grep with the pcre USE flag enabled."
		exit 1
	fi
}

cleanups() {
	echo "cleanup() called"
	rm -rf "${DIR_SCRIPT}/package.env.t"*
	rm -rf "${DIR_SCRIPT}/sandbox"
	rm -rf "${DIR_SCRIPT}/dump.txt"

	# It still loops even though I told it to stop with CTRL+C
	killall -9 gen_package_env
}

gen_overlay_paths() {
	local _overlay_paths=(
		${PORTAGE_DIR}
		${OILEDMACHINE_OVERLAY_DIR}
		$(find "${LAYMAN_BASEDIR}" -maxdepth 1 -type d \( -name "profiles" -o -name "metadata" \) \
			| sed -r -e "s/(metadata|profiles)//g" \
			| sed -e "s|/$||g" \
			| sort \
			| uniq)
	)
	export OVERLAY_PATHS="${_overlay_paths[@]}"
}

# This is very expensive to do a lookup
gen_tarball_to_p_dict() {
	unset A_TO_P
	declare -Ag A_TO_P
	local cache_path="${DIR_SCRIPT}/a_to_p.cache"
	if [[ -e "${cache_path}" ]] ; then
		local ts=$(stat -c "%W" "${cache_path}")
		local now=$(date +"%s")
		if (( ${ts} + 86400 >= ${now} )) ; then # Expire in 1 day
			echo "Using cached A_TO_P hashmap.  Delete it after emerge --sync."
			eval "$(cat ${cache_path})"
			if ! declare -p A_TO_P 2>&1 > /dev/null ; then
				echo "Failed to init A_TO_P"
				exit 1
			fi
			return
		fi
	fi
	echo "Generating archive to \${CATEGORY}/\${P} hashmap.  Please wait..."
	local op
	for op in ${OVERLAY_PATHS[@]} ; do
		local path
		for path in $(find "${op}" -type f -name "Manifest") ; do
			echo "Inspecting ${path}"
			local idx_pn=$(get_path_pkg_idx "${path}")
			local idx_cat=$(( ${idx_pn} - 1 ))
			local cat_p=$(echo "${path}" | cut -f ${idx_cat}-${idx_pn} -d "/")
			local pn=$(echo "${path}" | cut -f ${idx_pn} -d "/")
			grep -q -e "DIST" "${path}" || continue
			local line
			for line in $(grep -e "DIST" "${path}") ; do
				local a=$(echo "${line}" | cut -f 2 -d " ")
				local hc="S"$(echo -n "${a}" | sha1sum | cut -f 1 -d " ")
				A_TO_P[${hc}]="${cat_p}"
			done
		done
	done
	# Serialized data
	declare -p A_TO_P > "${cache_path}"
	sed -i -e "s|declare -A |declare -Ag |g" "${cache_path}"
}

main()
{
	if [[ "${DEVELOPER_MODE}" != "1" ]] ; then
		echo "${SCRIPT_NAME} is under construction"
		echo "Do not use yet!"
		return
	fi
	setup
	gen_overlay_paths
	gen_tarball_to_p_dict
	header
	archives_autofetch
	gen_package_env
	footer
}

main
