Add `pragma GCC unroll n` for better unrolling than -funroll-loops for
some parts related to internal sha1 and sha256.

Package:  git 2.26.3

Compiler:  gcc version 10.2.0

Author:  Orson Teodoro <orsonteodoro@hotmail.com>

Project license:  https://github.com/git/git/blob/v2.26.3/LGPL-2.1

sha1dc/sha1.c copyright noice and license:

/***
* Copyright 2017 Marc Stevens <marc@marc-stevens.nl>, Dan Shumow (danshu@microsoft.com)
* Distributed under the MIT Software License.
* See accompanying file LICENSE.txt or copy at
* https://opensource.org/licenses/MIT
***/

sha1dc/sha1.c is not being used on Gentoo but left for upstream or users that
are interested in unrolling those parts if interested.

diff -urp git-2.26.3.orig/block-sha1/sha1.c git-2.26.3/block-sha1/sha1.c
--- git-2.26.3.orig/block-sha1/sha1.c	2021-03-08 12:28:28.000000000 -0800
+++ git-2.26.3/block-sha1/sha1.c	2021-05-08 21:48:18.519080986 -0700
@@ -246,6 +246,7 @@ void blk_SHA1_Final(unsigned char hashou
 	blk_SHA1_Update(ctx, padlen, 8);
 
 	/* Output hash */
+	#pragma GCC unroll 5
 	for (i = 0; i < 5; i++)
 		put_be32(hashout + i * 4, ctx->H[i]);
 }
diff -urp git-2.26.3.orig/sha1dc/sha1.c git-2.26.3/sha1dc/sha1.c
--- git-2.26.3.orig/sha1dc/sha1.c	2021-03-08 12:28:28.000000000 -0800
+++ git-2.26.3/sha1dc/sha1.c	2021-05-08 21:48:24.329308204 -0700
@@ -195,6 +195,8 @@ void sha1_compression(uint32_t ihv[5], c
 	unsigned i;
 
 	memcpy(W, m, 16 * 4);
+
+	#pragma GCC unroll 64
 	for (i = 16; i < 80; ++i)
 		W[i] = sha1_mix(W, i);
 
@@ -1739,6 +1741,7 @@ static void sha1_process(SHA1_CTX* ctx,
 			{
 				if (ubc_dv_mask[0] & ((uint32_t)(1) << sha1_dvs[i].maskb))
 				{
+					#pragma GCC unroll 80
 					for (j = 0; j < 80; ++j)
 						ctx->m2[j] = ctx->m1[j] ^ sha1_dvs[i].dm[j];
 
diff -urp git-2.26.3.orig/sha256/block/sha256.c git-2.26.3/sha256/block/sha256.c
--- git-2.26.3.orig/sha256/block/sha256.c	2021-03-08 12:28:28.000000000 -0800
+++ git-2.26.3/sha256/block/sha256.c	2021-05-08 21:48:21.169184620 -0700
@@ -62,14 +62,17 @@ static void blk_SHA256_Transform(blk_SHA
 	int i;
 
 	/* copy state into S */
+	#pragma GCC unroll 8
 	for (i = 0; i < 8; i++)
 		S[i] = ctx->state[i];
 
 	/* copy the state into 512-bits into W[0..15] */
+	#pragma GCC unroll 16
 	for (i = 0; i < 16; i++, buf += sizeof(uint32_t))
 		W[i] = get_be32(buf);
 
 	/* fill W[16..63] */
+	#pragma GCC unroll 48
 	for (i = 16; i < 64; i++)
 		W[i] = gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16];
 
@@ -144,6 +147,7 @@ static void blk_SHA256_Transform(blk_SHA
 	RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],62,0xbef9a3f7);
 	RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],63,0xc67178f2);
 
+	#pragma GCC unroll 8
 	for (i = 0; i < 8; i++)
 		ctx->state[i] += S[i];
 }
@@ -191,6 +195,7 @@ void blk_SHA256_Final(unsigned char *dig
 	blk_SHA256_Update(ctx, padlen, 8);
 
 	/* copy output */
+	#pragma GCC unroll 8
 	for (i = 0; i < 8; i++, digest += sizeof(uint32_t))
 		put_be32(digest, ctx->state[i]);
 }
